# Ogawayama stubとserver間のcommunication
2019.08.13 NT 堀川　First edition  
2019.08.20 NT 堀川　Revise  
2019.08.20 NT 堀川　R2 (channel_xxxもフロントエンドが作成する）  
2019.09.12 NT 堀川　R3 (V0の実装に合わせて内容を更新）  
2019.09.18 NT 堀川　R4 (接続時の動作を微修正）  
2019.09.18 NT 堀川　R5 (メッセージ授受を共有メモリ経由で行うことに伴う変更）  
2019.12.11 NT 堀川　R6 (複数rowを一括転送する機能の実装に伴う変更）

本メモは、stubとserver間で行う通信処理の概要を示す。

## 用語定義
* 「通信」とは、stub（PostgreSQL側）とserver（umikongo側）の間で行うデータ転送または同期処理を意味する。  
* PostgeSQLワーカープロセスの間、および、umikongoスレッドの間で行うデータ転送や同期処理は「通信」に含めない。
* 「通信路」は、データと制御を受け渡す媒体を意味する。
  * 必要に応じてフロントエンドとバックエンド間に通信路を設置する。
  * 各通信路には、通信路を特定するためのユニークな文字列（通信路の名前）を与える。
  * 一通信路で、処理要求メッセージ、処理結果メッセージ、Ack（データ受け渡しなし）の通信を可能とする。  
    メッセージとして受け渡すデータは共有メモリに格納したうえで、メッセージ格納を相手先に通知する（制御を受け渡す）ためにmutexを用いる。
    Ackの場合は、mutexのみを用いる。
* 一つの通信路には、送信側の一プロセス（スレッド）と受信側の一プロセス（スレッド）*)のみが関わる。
* 「行データキュー」は、共有メモリ内に配置するデータ構造であり、select結果として得られる複数行の受け渡しを目的とする行データのFIFOキュー、Metadataの受け渡しを目的とするMetadata構造体、受け渡す行数を示す変数（以下、requested）を持つ。
  * 1つの行データキューが1つのresultSetに対応する。バックエンドは、フロントエンドによる複数resultSetの同時使用を可能とする。
* 「ブロッキング」とは、あるプロセス（スレッド）が、通信の相手方プロセス（スレッド）による何らかの通信操作を、CPUを使った処理を行わずに、待つことを意味する。

*)Stub側のPostgeSQLワーカープロセスとserver側の実行エンジン（umikongo）スレッドが通信に関わるので、厳密には「プロセス（スレッド）」と表記すべきであるが、本メモでは説明の簡潔さを優先し、これ以降、両者を総称して「スレッド」と表記する。

## 通信に関わるスレッド
以下のスレッドが通信に関与する
### Stub
* フロントエンド・ワーカー：バックエンドに対してトランザクション処理を要求するスレッド。
複数スレッドが同時に動作可能。

### Server
* バックエンド・サーバ：フロントエンド・ワーカーからの接続要求を受け付け、フロントエンド・ワーカーに対応するバックエンド・ワーカーを割当てる。
スレッド数は１。
* バックエンド・ワーカー：対応するフロントエンド・ワーカーが要求するトランザクション処理要求を受け付けて実行し、
その処理結果をフロントエンド・ワーカーに戻す。バックエンドは、複数ワーカー・スレッドの同時動作を可能とする。

### 通信の種類と通信路
通信路を介して行う通信の関係を下表に示す。
| 通信の種類 | 通信方向 | 通信路の名前 | 
|-:|:-|:-|
| 接続要求 | フロントエンド・ワーカー → バックエンド・サーバ | Server |
| 処理要求と結果 | フロントエンド・ワーカー ←→ バックエンド・ワーカー | channel_xxx |
ここで、xxxはフロントエンド・ワーカーを識別する番号。

また、行データキューは、バックエンド・ワーカーからフロントエンド・ワーカーにselect結果を受け渡すために使用する。
以下、その名前をRowQueue_xxx_nnと表記する。
フロントエンドは、複数のresultSetを同時に使用する可能性があるため、nnをresultSetを識別する番号として付与する。

## 通信フロー
### 初期状態（前提）
* バックエンド
  * 起動済
  * 通信路（"Server"）を作成済
  * バックエンド・サーバは通信路（"Server"）からの接続要求メッセージを待っている状態（ブロッキング①開始）
* フロントエンド・ワーカーは未起動

### 接続要求
ユーザ（フロントエンドのアプリ）からの処理要求をフロントエンドが受け付けると、フロントエンドは新たに
フロントエンド・ワーカー・プロセスを作成する（◇）。以下は、フロントエンド・ワーカー起動時の動作。
* フロントエンド・ワーカー
  * 起動（◇）
  * 通信路（"channel_xxx"）を作成
  * 通信路（"Server"）に接続要求メッセージを送信（ブロッキング①解除）
  * 通信路（"Server"）からのAck受信を待つ（ブロッキング⑩）
  * 通信路（"channel_xxx"）からのメッセージ（準備完了）受信を待つ（ブロッキング⑪）
  * 動作を継続し、処理要求（次項）を行う
* バックエンド・サーバ
  * 通信路（"Server"）から接続要求メッセージを受信（ブロッキング①終了）
  * 通信路（"Server"）にAckを送信（ブロッキング⑩解除）
  * 受信したメッセージに従ってバックエンド・ワーカーを起動する（□）
  * 通信路（"Server"）からの接続要求メッセージ受信を待つ（ブロッキング①開始に戻る）
* バックエンド・ワーカー
  * 起動（□）
  * 通信路（"channel_xxx"）に接続
  * 通信路（"channel_xxx"）にメッセージ（準備完了）を送信（ブロッキング⑪解除）
  * 通信路（"channel_xxx"）からの処理要求メッセージを待つ（ブロッキング②開始）  
ここで、xxxはフロントエンド・ワーカーを識別する番号。PostgreSQLでは、MyProc->pgprocnoの使用が適切。

### 処理要求（execute_statement）
* フロントエンド・ワーカー
  * 通信路（"channel_xxx"）に処理要求（ステートメント）メッセージを送信（ブロッキング②解除）
  * 通信路（"channel_xxx"）からの処理結果（ステートメント）メッセージ受信を待つ（ブロッキング⑫開始）
  * 通信路（"channel_xxx"）からの処理結果（ステートメント）メッセージを受信（ブロッキング⑫終了）すると
    処理結果をexecute_statement()の要求元へ戻す
* バックエンド・ワーカー
  * 通信路（"channel_xxx"）から処理要求（ステートメント）メッセージを受信（ブロッキング②終了）
  * 受信したメッセージに従ってデータベース処理を実行
  * 通信路（"channel_xxx"）に処理結果メッセージ（ステートメント）を送信（ブロッキング⑫解除）
  * ブロッキング②に戻る
  
### 処理要求（execute_query）
ここでは、複数行転送機能を有効にした場合の動作を示す。

* フロントエンド・ワーカー
  * 要求フェーズ（Transection->execute_query()実行時）
    * 行データキュー（"RowQueue_xxx_nn"）を作成（または選択）
    * 行データキュー（"RowQueue_xxx_nn"）のrequestedに、その行データキューで受け取り可能な行数を設定
    * 通信路（"channel_xxx"）に処理要求（クエリ）メッセージを送信（ブロッキング②解除）
    * 通信路（"channel_xxx"）からの処理要求受領（クエリ）メッセージ受信を待つ（ブロッキング⑬開始）
    * 通信路（"channel_xxx"）からの処理要求受領（クエリ）メッセージを受信（ブロッキング⑬終了）すると要求元に制御を戻す。
    この時点で、行データキューのMetadata構造体にMetadataが格納されているので、以降に行われるユーザ（フロントエンドのアプリ）からのget_metadata()呼び出しに応じて要求元へ戻す。  
    ここで、nnは、クエリを識別する番号。stubが採番するのでユーザ（フロントエンドのアプリ）は意識する必要はない。
  * 行データ受け渡しフェーズ（resultSetのnext()実行時）
    * 行データキュー（"RowQueue_xxx_nn"）に処理結果（Row）が格納されている場合は要求元に制御を戻す。
      * Rowが存在する場合はOK、EndOfRow時はEndOfRowを戻り値とする。
      * Rowデータは、ユーザ（フロントエンドのアプリ）からのnext_column()呼び出しに応じて要求元へ戻す。
    * 処理結果（Row）が格納されていない場合は行データキューに処理結果が格納されるまでブロッキングにより待つ。但し、複数行転送機能を有効にした場合は、行データキューには既に処理結果（Row）が格納済（ブロッキングは発生しない）という想定。
    * 行データキュー（"RowQueue_xxx_nn"）から予め設定された（詳細は省略）行数を読み込んだ場合は、行データキュー（"RowQueue_xxx_nn"）のrequestedに、その時点の行データキューに追加で受け取り可能な行数を設定した上で、通信路（"channel_xxx"）に処理要求（next）メッセージを送信する（バックエンド・ワーカーに対する行データ補充要求）。
* バックエンド・ワーカー
  * 要求フェーズ（Transaction->execute_query()実行時）
    * 通信路（"channel_xxx"）から処理要求（クエリ）メッセージを受信（ブロッキング②終了）
    * 行データキュー（"RowQueue_xxx_nn"）に接続する。
    * 受信した処理要求（クエリ）メッセージからMetadataを作成し、行データキュー（"RowQueue_xxx_nn"）のMetadata格納用の構造体に格納する。
    * 通信路（"channel_xxx"）に処理要求受領（クエリ）メッセージを送信（ブロッキング⑬解除）する。
    * クエリに従ってデータベース処理（クエリ）を以下の通りに実行する。（以降、これを処理△と呼ぶ）
      * 行データキュー（"RowQueue_xxx_nn"）のrequestedに設定された行数分の処理結果（Row）を作成する。
      * 上記の処理結果（Row）を行データキュー（"RowQueue_xxx_nn"）に格納する。
      * requestedに設定された行数分のRowが存在しない場合は、最終行の処理結果としてEndOfRowを行データキューに格納し、処理△を終了する。
  * 行データ補充要求受信時
    * 処理△を実行後、通信路（"channel_xxx"）からの処理要求待ち（ブロッキング②）に戻る。

### トランザクション終了（commit, rollback）
* フロントエンド・ワーカー
  * 通信路（"channel_xxx"）に処理要求（commitまたはrollback）メッセージを送信（ブロッキング②解除）
  * 通信路（"channel_xxx"）からの処理結果（commitまたはrollback）メッセージ受信を待つ（ブロッキング⑭開始）
  * 通信路（"channel_xxx"）からの処理結果（commitまたはrollback）メッセージを受信（ブロッキング⑭終了）すると
  * 処理結果をcommit()またはrollback()の要求元へ戻す
* バックエンド・ワーカー
  * 通信路（"channel_xxx"）から処理要求（commitまたはrollback）メッセージを受信（ブロッキング②終了）
  * 受信したメッセージに従ってデータベース処理を実行
  * 通信路（"channel_xxx"）に処理結果メッセージ（commitまたはrollback）を送信（ブロッキング⑭解除）
  * ブロッキング②に戻る

### 接続終了
* フロントエンド・ワーカー
  * 通信路（"channel_xxx"）に接続終了メッセージを送信（ブロッキング②解除）
  * 通信路（"channel_xxx"）からのAck受信を待つ（ブロッキング⑯）
  * 通信路（"channel_xxx"）からのAckを受信（）すると接続終了の要求元へ制御を戻す
* バックエンド・ワーカー
  * 通信路（"channel_xxx"）から接続終了メッセージを受信（ブロッキング②終了）
  * 通信路（"channel_xxx"）にAckを送信（ブロッキング⑯解除）
  * 自スレッドを終了する

## 通信メッセージ
### 通信路：Server
| 種類（コマンド） | オペランド |　解除されるブロッキング　| 補足 |
|-:|:-|:-|:-|
| 接続要求 | フロントエンド・ワーカー番号 | ブロッキング① | |

### 通信路：channel_xxx
| 種類（コマンド） | オペランド |　解除されるブロッキング　|　補足 |
|-:|:-|:-|:-|
| 処理要求（ステートメント） | SQL文 | ブロッキング② |
| 処理要求（クエリ） | SQL文、行データキュー番号 | ブロッキング② | 行データキューのrequestedに<br>設定された行数（またはEoRまで）<br>を読み込んでキューに書き込む |
| next | 行データキュー番号 | ブロッキング② | 同上 |
| 処理要求（commit） || ブロッキング② |
| 処理要求（rollback） || ブロッキング② |
| 接続終了 || ブロッキング② | Ackにより受領を通知
上記は、バックエンド・ワーカーがブロッキング②の解除時に受け取る可能性のあるメッセージ。

### 通信路：channel_xxx
| 種類（コマンド） | オペランド |　解除されるブロッキング　|
|-:|:-|:-|
| 準備（接続）完了 | 接続結果enum値 | ブロッキング⑪ |
| 処理結果（ステートメント） | 処理結果enum値 | ブロッキング⑫ |
| 処理要求受領（クエリ） | 処理結果enum値 | ブロッキング⑬ |
| 処理結果（commitまたはrollback） | 処理結果enum値 | ブロッキング⑭ |

## 以降の拡張
### 初期設定
最大フロントエンド・ワーカー数といったフロントエンドーバックエンド接続に関するパラメータを受け渡す必要が生じた場合は、初期設定のための通信メッセージを追加し、フロントエンドからバックエンドへのパラメータ受け渡しを可能とする必要がある。  
（現時点では、フロントエンド・ワーカー数は動的に拡大するようになっている。）

### 死活監視
V1では、timed_mutexを用いた簡易的なstall防止機能を実装した。実用化に際しては、死活監視機能の実装も必要である。
