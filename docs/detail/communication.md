# Ogawayama stubとserver間のcommunication
2019.08.13 NT 堀川　First edition  
2019.08.20 NT 堀川　Revise  
2019.08.20 NT 堀川　R2 (request_xxxもフロントエンドが作成する）  
2019.09.12 NT 堀川　R3 (V0の実装に合わせて内容を更新）

本メモは、V0のstubとserver間で行う通信処理の概要を示す。  

## 用語定義
* 「通信」とは、stub（PostgreSQL側）とserver（umikongo側）の間で行うデータ転送または同期処理を意味する。  
* PostgeSQLワーカープロセスの間、および、umikongoスレッドの間で行うデータ転送や同期処理は「通信」に含めない。
* 「通信路」は、データや制御を受け渡す媒体を意味する。
  * 必要に応じてフロントエンドとバックエンド間に複数の通信路を設置する。
  * 各通信路には、通信路を特定するためのユニークな文字列（通信路の名前）を与える。
  * 一通信路で、メッセージ（データ受け渡しあり）とAck（データ受け渡しなし）の二種類の通信を可能とする。  
  それらの用途としては、1)メッセージは送信側から受信側、2)Ackは受信側から送信側への通信を想定する。
* 一つの通信路には、送信側の一プロセス（スレッド）と受信側の一プロセス（スレッド）*)のみが関わる。
* 「行データキュー」は、共有メモリ内に配置するデータ構造であり、select結果として得られる複数行の受け渡しを目的とする行データのFIFOキューと、Metadataの受け渡しを目的とするMetadata構造体を持つ。
  * 同一のサーバ内で送信側と受信側が動作している場合は、行データキューにより行データの受け渡しを行うことで、シリアライズ・デシリアライズのオーバヘッドを削減する。
  * 1つの行データキューが1つのResultSetに対応する。フロントエンドが複数のResultSetを同時に使用することは可能。
* 「ブロッキング」とは、あるプロセス（スレッド）が、通信の相手方プロセス（スレッド）による何らかの通信操作を、CPUを使った処理を行わずに、待つことを意味する。

*)Stub側のPostgeSQLワーカープロセスとserver側の実行エンジン（umikongo）スレッドが通信に関わるので、厳密には「プロセス（スレッド）」と表記すべきであるが、本メモでは説明の簡潔さを優先し、これ以降、両者を総称して「スレッド」と表記する。

## 通信に関わるスレッド
以下のスレッドが通信に関与する
### Stub
* フロントエンド・ワーカー：バックエンドに対してトランザクション処理を要求するスレッド。
複数スレッドが同時に動作可能。

### Server
* バックエンド・サーバ：フロントエンド・ワーカーからの接続要求を受け付け、フロントエンド・ワーカーに対応するバックエンド・ワーカーを割当てる。
スレッド数は１。
* バックエンド・ワーカー：対応するフロントエンド・ワーカーが要求するトランザクション処理要求を受け付けて実行し、
その処理結果をフロントエンド・ワーカーに戻す。複数スレッドが同時に動作可能。

### 通信の種類と通信路
通信路を介して行う通信の関係を下表に示す。
| 通信の種類 | 通信方向 | 通信路の名前 | 
|-:|:-|:-|
| 接続要求 | フロントエンド・ワーカー → バックエンド・サーバ | Server |
| 処理要求 | フロントエンド・ワーカー → バックエンド・ワーカー | Request_xxx |
| 処理結果 | バックエンド・ワーカー → フロントエンド・ワーカー | Result_xxx |
ここで、xxxはフロントエンド・ワーカーを識別する番号。

また、行データキューは、バックエンド・ワーカーからフロントエンド・ワーカーにselect結果を受け渡すために使用する。
以下、その名前をRowQueue_xxx_nnと表記する。
フロントエンドは、複数のResultSetを同時に使用する可能性があるため、nnをResultSetを識別する番号として付与する。

## 通信フロー
### 初期状態（前提）
* バックエンド
  * 起動済
  * 通信路（"Server"）を作成済
  * バックエンド・サーバは通信路（"Server"）からの接続要求メッセージを待っている状態（ブロッキング①開始）
* フロントエンド・ワーカーは未起動

### 接続要求
ユーザ（フロントエンドのアプリ）からの処理要求をフロントエンドが受け付けると、フロントエンドは新たに
フロントエンド・ワーカー・プロセスを作成する（◇）。以下は、フロントエンド・ワーカー起動時の動作。
* フロントエンド・ワーカー
  * 起動（◇）
  * 通信路（"Result_xxx"）と通信路（"Request_xxx"）を作成
  * 通信路（"Server"）に接続要求メッセージを送信（ブロッキング①解除）
  * 通信路（"Result_xxx"）からのメッセージ（準備完了）受信を待つ（ブロッキング⑪）
  * 動作を継続し、処理要求（次項）を行う
* バックエンド・サーバ
  * 通信路（"Server"）から接続要求メッセージを受信（ブロッキング①終了）
  * 受信したメッセージに従ってバックエンド・ワーカーを起動する（□）
  * 通信路（"Server"）からの接続要求メッセージ受信を待つ（ブロッキング①開始に戻る）
* バックエンド・ワーカー
  * 起動（□）
  * 通信路（"Result_xxx"）と通信路（"Request_xxx"）に接続
  * 通信路（"Result_xxx"）にメッセージ（準備完了）を送信（ブロッキング⑪解除）
  * 通信路（"Request_xxx"）からの処理要求メッセージを待つ（ブロッキング②開始）  
ここで、xxxはフロントエンド・ワーカーを識別する番号。PostgreSQLでは、MyProc->pgprocnoの使用が適切。

### 処理要求（execute_statement）
* フロントエンド・ワーカー
  * 通信路（"Request_xxx"）に処理要求（ステートメント）メッセージを送信（ブロッキング②解除）
  * 通信路（"Result_xxx"）からの処理結果（ステートメント）メッセージ受信を待つ（ブロッキング⑫開始）
  * 処理結果をexecute_statement()の要求元へ戻す
* バックエンド・ワーカー
  * 通信路（"Request_xxx"）から処理要求（ステートメント）メッセージを受信（ブロッキング②終了）
  * 受信したメッセージに従ってデータベース処理を実行
  * 通信路（"Result_xxx"）に処理結果メッセージ（ステートメント）を送信（ブロッキング⑫解除）
  * ブロッキング②に戻る
  
### 処理要求（execute_query）
ここでは、各next()の呼び出しに応じてメッセージをやり取りするnaiveな方式（V0の実装）を示す。

* フロントエンド・ワーカー
  * 要求フェーズ（Transection->execute_query()実行時）
    * 行データキュー（"RowQueue_xxx_nn"）を作成（または選択）
    * 通信路（"Request_xxx"）に処理要求（クエリ）メッセージを送信（ブロッキング②解除）
    * 通信路（"Result_xxx"）からの処理要求受領（クエリ）メッセージ受信を待つ（ブロッキング⑬開始）
    * 通信路（"Result_xxx"）からの処理要求受領（クエリ）メッセージを受信（ブロッキング⑬終了）すると要求元に制御を戻す。
    この時点で、行データキューのMetadata構造体にMetadataが格納されているので、以降に行われるユーザ（フロントエンドのアプリ）からのget_metadata()呼び出しに応じて要求元へ戻す。  
    ここで、nnは、クエリを識別する番号。stubが採番するのでユーザ（フロントエンドのアプリ）は意識する必要はない。
  * 行データ受け渡しフェーズ（ResultSetのnext()実行時）  
    * 通信路（"Request_xxx"）に処理要求（next）メッセージを送信
    * 行データキュー（"RowQueue_xxx_nn"）に処理結果（Row）が格納されるのを待つ（ブロッキング⑭開始）
    * 行データキュー（"RowQueue_xxx_nn"）から処理結果（Row）が格納される（ブロッキング⑭終了）と要求元に制御を戻す。  
    Rowが存在する場合はOK、EndOfRow時はEndOfRowを戻り値とする。  
    Rowデータは、ユーザ（フロントエンドのアプリ）からのnext_column()呼び出しに応じて要求元へ戻す。

* バックエンド・ワーカー
  * 要求フェーズ（Transaction->execute_query()実行時）
    * 通信路（"Request_xxx"）から処理要求（クエリ）メッセージを受信（ブロッキング②終了）
    * 行データキュー（"RowQueue_xxx_nn"）に接続
    * 受信した処理要求（クエリ）メッセージからMetadataを作成し、行データキュー（"RowQueue_xxx_nn"）のMetadata格納用の構造体に格納する。
    * 通信路（"Request_xxx"）に処理要求受領（クエリ）メッセージを送信（ブロッキング⑬解除）
    * クエリに従ってデータベース処理（クエリ）を実行し、処理結果（Row）を作成（以降、これを処理△と呼ぶ）  
  * 行データ受け渡しフェーズ（ResultSetのnext()実行時） 
    * 行データキュー（"RowQueue_xxx_nn"）に処理結果（Row）を格納（ブロッキング⑭解除）
      * Rowが存在する場合 → 処理△に戻る
      * Rowが存在しない場合 → ブロッキング②に戻る、このときは、処理結果（EndOfRow）を行データキューに格納する
    * 通信路（"Request_xxx"）に別の処理要求（statementまたはquery）が届いている場合は、それを読み込む。  

## 通信メッセージ
### 通信路：Server
| 種類（コマンド） | オペランド |　解除されるブロッキング　| 補足 |
|-:|:-|:-|:-|
| 接続要求 | フロントエンド・ワーカー番号 | ブロッキング① | |

### 通信路：Request_xxx
| 種類（コマンド） | オペランド |　解除されるブロッキング　|　補足 |
|-:|:-|:-|:-|
| 処理要求（ステートメント） | SQL文 | ブロッキング② |
| 処理要求（クエリ） | SQL文、行データキュー番号 | ブロッキング② |
| next | 行データキュー番号[、行数] | ブロッキング② | 行数は∞（EoRまで読み込む）を含む <br> v0では行数は実装しない |
バックエンド・ワーカーがブロッキング②の解除時に受け取る可能性のあるメッセージは、上記の３種類。

### 通信路：Result_xxx
| 種類（コマンド） | オペランド |　解除されるブロッキング　|
|-:|:-|:-|
| 準備（接続）完了 | 接続結果enum値 | ブロッキング⑪ |
| 処理結果（ステートメント） | 処理結果enum値 | ブロッキング⑫ |
| 処理要求受領（クエリ） | 処理結果enum値 | ブロッキング⑬ |


## V1以降の拡張
### execute_query()に伴うrowデータの受け渡し
next()により１行ずつ転送するのではなく、非同期の転送、または複数行の一括転送とすることで、next()に伴うメッセージのやり取りに伴うdelayを削減できる。  
この機能の実現に際しては、通信路（"RowQueue_xxx_nn"）に書き込める行数に上限があることに対象する必要がある。フロントエンド・ワーカーが通信路（"RowQueue_xxx_nn"）から行を取り出したことをバックエンド・ワーカーが知る手段等が考えられる（詳細は未検討）。  
なお、フロントエンド・ワーカーはEndOfRowに到達するまでnext()を送り続けるとは限らない（EndOfRowを受け取る前にresult_setが不要になる場合がある）ので、 メモリ・リソースの有効活用のためには、result_setに対応する通信路（"RowQueue_xxx_nn"）の使用終了を通知するメッセージが必要となる。

### 初期設定
最大フロントエンド・ワーカー数といったフロントエンドーバックエンド接続に関するパラメータを受け渡す必要が生じた場合は、初期設定のための通信メッセージを追加し、フロントエンドからバックエンドへのパラメータ受け渡しを可能とする必要がある。  
（V0では、フロントエンド・ワーカー数は動的に拡大する。）