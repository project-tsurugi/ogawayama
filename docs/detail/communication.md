# Ogawayama stubとserver間のcommunicatio1
2019.08.13 NT 堀川　First edition
2019.08.20 NT 堀川　Revise
2019.08.20 NT 堀川　R2 (request_xxxもフロントエンドが作成する）

本メモは、stubとserver間で行う通信処理の概要を示す。  

## 用語定義
* 「通信」とは、stub（PostgreSQL側）とserver（umikongo側）の間で行うデータ転送または同期処理を意味する。  
* PostgeSQLワーカープロセス間、および、umikongoスレッド間で行うデータ転送や同期処理は「通信」に含めない。
* 「通信路」は、データや制御を受け渡す媒体を意味する。
  * 必要に応じてフロントエンドとバックエンド間に複数の通信路を設置する。
  * 各通信路には、通信路を特定するためのユニークな文字列（通信路の名前）を与える。
  * 一通信路で、メッセージ（データ受け渡しあり）とAck（データ受け渡しなし）の二種類の通信を可能とする。  
  それらの用途としては、1)メッセージは送信側から受信側、2)Ackは受信側から送信側への通信を想定する。
* 一つの通信路には、送信側の一プロセス（スレッド）と受信側の一プロセス（スレッド）*)のみが関わる。
* 「行データキュー」は、select結果として得られる複数行の受け渡しを目的として共有メモリ内に配置する行データのFIFOキューを意味する。
  * 同一サーバ内で送信側と受信側が動作している場合は、行データキューにより行データの受け渡しを行うことで、シリアライズ・デシリアライズのオーバヘッドを削減する。
  * 1つの行データキューが1つのResultSetに対応する。
* 「ブロッキング」とは、あるプロセス（スレッド）が、通信の相手方プロセス（スレッド）による何らかの通信操作を、
単に（何らかの処理を行うことなく）待つことを意味する。

*)Stub側のPostgeSQLワーカープロセスとserver側の実行エンジン（umikongo）スレッドが通信に関わるので、
厳密には「プロセス（スレッド）」と表記すべきであるが、本メモでは説明の簡潔さを優先し、
これ以降、両者を総称して「スレッド」と表記する。


## 通信に関わるスレッド
以下のスレッドが通信に関与する
### Stub
* プライマリ：フロントエンドの起動時における初期設定を行うスレッド。スレッド数は１。
* フロントエンド・ワーカー：バックエンドに対してトランザクション処理を要求するスレッド。
複数スレッドが同時に動作可能。

### Server
* サーバ：フロントエンド・ワーカーからの接続要求を受け付け、フロントエンド・ワーカーに対応するバックエンド・ワーカーを割当てる。
スレッド数は１。
* バックエンド・ワーカー：対応するフロントエンド・ワーカーが要求するトランザクション処理要求を受け付けて実行し、
その処理結果をフロントエンド・ワーカーに戻す。複数スレッドが同時に動作可能。

### 通信の種類と通信路
通信路を介して行う通信の関係を下表に示す。
| 通信の種類 | 通信方向 | 通信路の名前 | 
|-:|:-|:-|
| 初期設定<br>接続要求 | プライマリ → サーバ<br>フロントエンド・ワーカー → サーバ | Server |
| 処理要求 | フロントエンド・ワーカー → バックエンド・ワーカー | Request_xxx |
| 処理結果 | バックエンド・ワーカー → フロントエンド・ワーカー | Result_xxx |
ここで、xxxはフロントエンド・ワーカーを識別する番号。

また、行データキューは、バックエンド・ワーカーからフロントエンド・ワーカーにselect結果を受け渡すために使用する。
以下、その名前をRowQueue_xxx_nnと表記する。
フロントエンドは、複数のResultSetを同時に使用する可能性があるため、nnをResultSetを識別する番号として付与する。


## 通信フロー
### 初期状態（前提）
* バックエンド
  * 起動済
  * 通信路（"Server"）を作成済
  * サーバは通信路（"Server"）からの初期設定メッセージを待っている状態（ブロッキング①開始）
* フロントエンド（プライマリ）は未起動

### 初期設定
初期状態にてフロントエンドを起動（◆）すると、以下の初期化操作を経てフロントエンド-バックエンド連携が使用可能になる。
* フロントエンド（プライマリ）
  * 起動（◆）
  * 通信路（"Server"）に初期設定メッセージを書き込む（ブロッキング①解除）
  * 通信路（"Server"）からのAck受信を待つ（ブロッキング⑪）
  * （フロントエンドの動作に必要な）初期化処理を継続
* サーバ
  * 通信路（"Server"）から初期設定メッセージを受信（ブロッキング①終了）
  * 受信したメッセージに従ってフロントエンド-バックエンド連携に必要な初期化操作を行う
  * 通信路（"Server"）にAckを送信（ブロッキング⑪解除）
  * 通信路（"Server"）からの接続要求メッセージ受信を待つ（ブロッキング②開始）

### 接続要求
ユーザ（アプリ）からの処理要求をフロントエンドが受け付けると、フロントエンド（プライマリ）は
フロントエンド・ワーカー・プロセスを作成する（◇）。以下は、フロントエンド・ワーカー起動時の動作。
* フロントエンド・ワーカー
  * 起動（◇）
  * 通信路（"Result_xxx"）と通信路（"Request_xxx"）を作成
  * 通信路（"Server"）に接続要求メッセージを送信（ブロッキング②解除）
  * 通信路（"Result_xxx"）からのメッセージ（準備完了）受信を待つ（ブロッキング⑫）
  * 動作を継続し、処理要求（次項）を行う
* サーバ
  * 通信路（"Server"）から接続要求メッセージを受信（ブロッキング②終了）
  * 受信したメッセージに従ってバックエンド・ワーカーを起動する（□）
  * 通信路（"Server"）からの接続要求メッセージ受信を待つ（ブロッキング②開始に戻る）
* バックエンド・ワーカー
  * 起動（□）
  * 通信路（"Result_xxx"）と通信路（"Request_xxx"）に接続
  * 通信路（"Result_xxx"）にメッセージ（準備完了）を送信（ブロッキング⑫解除）
  * 通信路（"Request_xxx"）からの処理要求メッセージを待つ（ブロッキング③開始）

### 処理要求（execute_statement）
* フロントエンド・ワーカー
  * 通信路（"Request_xxx"）に処理要求（ステートメント）メッセージを送信（ブロッキング③解除）
  * 通信路（"Request_xxx"）からのAck受信を待つ（ブロッキング⑬）
  * 通信路（"Result_xxx"）からの処理結果（ステートメント）メッセージ受信を待つ（ブロッキング⑭開始）
  * 処理結果をexecute_statement()の要求元へ戻す
* バックエンド・ワーカー
  * 通信路（"Request_xxx"）から処理要求（ステートメント）メッセージを受信（ブロッキング③終了）
  * 通信路（"Request_xxx"）にAckを送信（ブロッキング⑬解除）
  * 受信したメッセージに従ってデータベース処理を実行
  * 通信路（"Result_xxx"）に処理結果メッセージ（ステートメント）を送信（ブロッキング⑭解除）
  * ブロッキング③に戻る
  
### 処理要求（execute_query）
ここでは、各next()の呼び出しに応じてメッセージをやり取りするnaiveな実装（V0で想定）を示す。

* フロントエンド・ワーカー
  * 要求フェーズ（Connection->execute_query()実行時）
    * 行データキュー（"RowQueue_xxx_nn"）を作成（または選択）
    * 通信路（"Request_xxx"）に処理要求（クエリ）メッセージを送信（ブロッキング③解除）
    * 通信路（"Request_xxx"）からのAck受信を待つ（ブロッキング⑭）
    * 通信路（"Result_xxx"）からの処理結果（Metadata）メッセージ受信を待つ（ブロッキング⑮開始）
    * 通信路（"Result_xxx"）から処理結果（Metadata）メッセージを受信（ブロッキング⑮終了）  
    Metadataを一時保存し、要求元に制御を戻す。Metadataは、get_metadata()の呼び出しに応じて要求元へ戻す。
  * 行データ受け渡し（ResultSetのnext()実行時）  
    * 通信路（"Request_xxx"）に処理要求（next）メッセージを送信
    * 行データキュー（"RowQueue_xxx_nn"）に処理結果（Row）が格納されるのを待つ（ブロッキング⑯開始）
    * 行データキュー（"RowQueue_xxx_nn"）から処理結果（Row）が格納される（ブロッキング⑯終了）と要求元に制御を戻す。  
    Rowが存在する場合はOK、EndOfRow時はEndOfRowを戻り値とする。  
    Rowデータは、next_column()の呼び出しに応じて要求元へ戻す。

* バックエンド・ワーカー
  * 要求フェーズ（Connection->execute_query()実行時）
    * 通信路（"Request_xxx"）から処理要求（クエリ）メッセージを受信（ブロッキング③終了）
    * 行データキュー（"RowQueue_xxx_nn"）に接続
    * 通信路（"Request_xxx"）にAckを送信（ブロッキング⑭解除）
    * 受信した処理要求（クエリ）メッセージからMetadataを作成
    * 通信路（"Result_xxx"）に処理結果（Metadata）メッセージを送信（ブロッキング⑮解除）
    * クエリに従ってデータベース処理（クエリ）を実行し、処理結果（Row）を作成（処理△）  
  * 行データ受け渡し（ResultSetのnext()実行時） 
    * 行データキュー（"RowQueue_xxx_nn"）に処理結果（Row）を格納（ブロッキング⑯解除）
      * Rowが存在する場合 → 処理△に戻る
      * Rowが存在しない場合 → ブロッキング③に戻る、このときは、処理結果（EndOfRow）を行データキューに格納する
    * 通信路（"Request_xxx"）に処理要求が届いている場合は、それを読み込む。
    なお、フロントエンド・ワーカーはEndOfRowに到達するまでnext()を送り続けるとは限らない
    （EndOfRowを受け取る前に次のステートメントやクエリの処理要求を行う可能性がある）ので、
    送られたコマンドがnextでない場合には、ブロッキング③が解除された場合の処理を行う。

## 通信メッセージ
### 通信路：Server
| 種類（コマンド） | オペランド |　解除されるブロッキング　|
|-:|:-|:-|
| 初期設定 | 最大フロントエンドワーカー数 | ブロッキング① |
| 接続要求 | フロントエンドワーカー番号 | ブロッキング② |

### 通信路：Request_xxx
| 種類（コマンド） | オペランド |　解除されるブロッキング　|　補足 |
|-:|:-|:-|:-|
| 処理要求（ステートメント） | SQL文 | ブロッキング③ |
| 処理要求（クエリ） | SQL文、行データキュー番号 | ブロッキング③ |
| next | 行データキュー番号[、行数] | 非同期（ブロッキングなし） | 行数は∞（EoRまで読み込む）を含む |

### 通信路：Result_xxx
| 種類（コマンド） | オペランド |　解除されるブロッキング　|
|-:|:-|:-|
| 準備（接続）完了 | 接続結果enum値 | ブロッキング⑫ |
| 処理結果（ステートメント） | 処理結果enum値 | ブロッキング⑬ |
| 処理結果（Metadata） | select結果のMetadata | ブロッキング⑮ |


## V1以降の拡張
execute_query()に伴うRowデータの受け渡しを非同期に行い、next()に伴うメッセージのやり取りを廃止する拡張が考えられる。
このプロトコルを実装するためには、1) 通信路（"Request_xxx"）に要求が到着しているか否かをノン・ブロッキングで確認する手段、
2) 通信路（"RowQueue_xxx_nn"）に溜まっている未受信データをクリアする手段が必要となる。
